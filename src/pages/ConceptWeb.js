import React, { useState, useEffect, useRef, useCallback } from 'react';
import { useNavigate } from 'react-router-dom';
import { 
  Sparkles, Plus, Trash2, ArrowLeft, Loader, Link as LinkIcon, 
  BookOpen, FileText, Brain, Filter, Search, TrendingUp, Download, 
  Eye, EyeOff, Grid, Network, BarChart3, CheckSquare, Square, 
  Maximize2, Minimize2, RefreshCw, Zap, Target, Move, Info 
} from 'lucide-react';
import './ConceptWeb.css';
import { API_URL } from '../config';

const ConceptWeb = () => {
  const navigate = useNavigate();
  const [userName, setUserName] = useState('');
  const [concepts, setConcepts] = useState([]);
  const [connections, setConnections] = useState([]);
  const [loading, setLoading] = useState(true);
  const [initialLoad, setInitialLoad] = useState(true);
  const [generating, setGenerating] = useState(false);
  const [selectedNode, setSelectedNode] = useState(null);
  const [hoveredNode, setHoveredNode] = useState(null);
  const [showAddModal, setShowAddModal] = useState(false);
  const [newConcept, setNewConcept] = useState({ name: '', description: '', category: '' });
  const [searchQuery, setSearchQuery] = useState('');
  const [filterCategory, setFilterCategory] = useState('all');
  const [sortBy, setSortBy] = useState('name');
  const [viewMode, setViewMode] = useState('network');
  const [selectedConcepts, setSelectedConcepts] = useState(new Set());
  const [showAnalytics, setShowAnalytics] = useState(false);
  const [highlightConnections, setHighlightConnections] = useState(null);
  const [isPanelCollapsed, setIsPanelCollapsed] = useState(false);
  const [generatingContent, setGeneratingContent] = useState(null);
  const [nodePositions, setNodePositions] = useState({});
  const [draggingNode, setDraggingNode] = useState(null);
  const [dragOffset, setDragOffset] = useState({ x: 0, y: 0 });
  const [isFullscreen, setIsFullscreen] = useState(false);
  const [fadeIn, setFadeIn] = useState(false);
  const [autoGenerated, setAutoGenerated] = useState(false);
  const [zoomLevel, setZoomLevel] = useState(1);
  const [panOffset, setPanOffset] = useState({ x: 0, y: 0 });
  const [isPanning, setIsPanning] = useState(false);
  const [panStart, setPanStart] = useState({ x: 0, y: 0 });
  const svgRef = useRef(null);
  const containerRef = useRef(null);

  // Initialize node positions in a beautiful circular layout
  const initializeNodePositions = useCallback((conceptsList) => {
    const positions = {};
    const centerX = 50;
    const centerY = 50;
    const radius = 35;
    const angleStep = (2 * Math.PI) / conceptsList.length;
    
    conceptsList.forEach((concept, index) => {
      const angle = index * angleStep - Math.PI / 2;
      const x = centerX + radius * Math.cos(angle);
      const y = centerY + radius * Math.sin(angle);
      
      positions[concept.id] = {
        x,
        y,
        vx: (Math.random() - 0.5) * 0.1,
        vy: (Math.random() - 0.5) * 0.1
      };
    });
    
    return positions;
  }, []);

  // Auto-load and auto-generate concept web on mount
  useEffect(() => {
    const token = localStorage.getItem('token');
    const username = localStorage.getItem('username');
    
    if (!token) {
      navigate('/login');
      return;
    }
    
    if (username) {
      setUserName(username);
      // Always try to generate fresh concepts when opening the page
      autoGenerateConceptWeb(username).then(() => {
        loadConceptWeb(username, false);
      });
    }
  }, [navigate]);

  // Reload concept web periodically to catch new concepts (without auto-regenerating)
  useEffect(() => {
    const username = localStorage.getItem('username');
    if (!username) return;
    
    const intervalId = setInterval(() => {
      loadConceptWeb(username, false);
    }, 30000); // Refresh every 30 seconds (just reload, don't regenerate)
    
    return () => clearInterval(intervalId);
  }, [userName]);

  // Pan handlers
  const handlePanStart = useCallback((e) => {
    if (e.button !== 0) return; // Only left mouse button
    setIsPanning(true);
    setPanStart({ x: e.clientX, y: e.clientY });
  }, []);

  const handlePanMove = useCallback((e) => {
    if (!isPanning) return;
    
    const dx = (e.clientX - panStart.x) * 0.1 / zoomLevel;
    const dy = (e.clientY - panStart.y) * 0.1 / zoomLevel;
    
    setPanOffset(prev => ({
      x: prev.x - dx,
      y: prev.y - dy
    }));
    
    setPanStart({ x: e.clientX, y: e.clientY });
  }, [isPanning, panStart, zoomLevel]);

  const handlePanEnd = useCallback(() => {
    setIsPanning(false);
  }, []);

  useEffect(() => {
    if (isPanning) {
      window.addEventListener('mousemove', handlePanMove);
      window.addEventListener('mouseup', handlePanEnd);
      return () => {
        window.removeEventListener('mousemove', handlePanMove);
        window.removeEventListener('mouseup', handlePanEnd);
      };
    }
  }, [isPanning, handlePanMove, handlePanEnd]);

  // Advanced touchpad/wheel zoom with pinch support
  useEffect(() => {
    const handleWheel = (e) => {
      // Support both Ctrl+wheel and touchpad pinch (which sends ctrlKey)
      if (e.ctrlKey || e.metaKey) {
        e.preventDefault();
        
        const svg = svgRef.current;
        if (!svg) return;
        
        // Get mouse position relative to SVG for zoom center
        const rect = svg.getBoundingClientRect();
        const mouseX = ((e.clientX - rect.left) / rect.width) * 100;
        const mouseY = ((e.clientY - rect.top) / rect.height) * 100;
        
        // Calculate zoom delta (negative deltaY = zoom in)
        const delta = e.deltaY * -0.001;
        const newZoom = Math.max(0.3, Math.min(5, zoomLevel * (1 + delta)));
        
        // Adjust pan to zoom towards mouse position
        const zoomRatio = newZoom / zoomLevel;
        setPanOffset(prev => ({
          x: mouseX - (mouseX - prev.x) * zoomRatio,
          y: mouseY - (mouseY - prev.y) * zoomRatio
        }));
        
        setZoomLevel(newZoom);
      } else if (!e.shiftKey) {
        // Regular scroll for panning (without shift)
        e.preventDefault();
        const sensitivity = 0.5;
        setPanOffset(prev => ({
          x: prev.x + e.deltaX * sensitivity / zoomLevel,
          y: prev.y + e.deltaY * sensitivity / zoomLevel
        }));
      }
    };

    const svg = svgRef.current;
    if (svg) {
      svg.addEventListener('wheel', handleWheel, { passive: false });
      return () => svg.removeEventListener('wheel', handleWheel);
    }
  }, [zoomLevel]);

  // Fade in animation after loading
  useEffect(() => {
    if (!loading && concepts.length > 0) {
      setTimeout(() => setFadeIn(true), 100);
    }
  }, [loading, concepts]);

  // Auto-generate if no concepts exist
  const loadConceptWeb = async (username, isInitial = false) => {
    try {
      setLoading(true);
      const token = localStorage.getItem('token');
      const response = await fetch(`${API_URL}/get_concept_web?user_id=${username}`, {
        headers: { 'Authorization': `Bearer ${token}` }
      });
      
      if (response.ok) {
        const data = await response.json();
        console.log('Loaded concept web data:', data);
        
        if (data.nodes && data.nodes.length > 0) {
          setConcepts(data.nodes);
          setConnections(data.connections || []);
          setNodePositions(initializeNodePositions(data.nodes));
        } else if (isInitial) {
          // Auto-generate on first load if no concepts
          console.log('No concepts found, auto-generating...');
          await autoGenerateConceptWeb(username);
        }
      }
    } catch (error) {
      console.error('Error loading concept web:', error);
    } finally {
      setLoading(false);
      setInitialLoad(false);
    }
  };

  // Auto-generate concept web (silently, no alerts)
  const autoGenerateConceptWeb = async (username) => {
    try {
      console.log('Auto-generating concept web from latest content...');
      const token = localStorage.getItem('token');
      const response = await fetch(`${API_URL}/generate_concept_web`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${token}`
        },
        body: JSON.stringify({ user_id: username })
      });
      
      if (response.ok) {
        const data = await response.json();
        console.log('Auto-generation result:', data);
        // Silently succeed - no alerts needed
        return data;
      }
    } catch (error) {
      console.error('Error auto-generating:', error);
      // Fail silently - user will see existing concepts or empty state
    }
  };

  const generateConceptWeb = async () => {
    if (!window.confirm('Generate concept web from your learning content?')) {
      return;
    }
    
    try {
      setGenerating(true);
      const token = localStorage.getItem('token');
      const response = await fetch(`${API_URL}/generate_concept_web`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${token}`
        },
        body: JSON.stringify({ user_id: userName })
      });
      
      if (response.ok) {
        const data = await response.json();
        if (data.status === 'no_content') {
          alert('No learning content found!');
        } else {
          alert(`Generated ${data.concepts_created} concepts!`);
          await loadConceptWeb(userName);
        }
      }
    } catch (error) {
      console.error('Error generating:', error);
    } finally {
      setGenerating(false);
    }
  };

  const addConcept = async () => {
    if (!newConcept.name.trim()) {
      alert('Please enter a concept name');
      return;
    }
    
    try {
      const token = localStorage.getItem('token');
      const response = await fetch(`${API_URL}/add_concept_node`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${token}`
        },
        body: JSON.stringify({
          user_id: userName,
          concept_name: newConcept.name,
          description: newConcept.description,
          category: newConcept.category || 'General'
        })
      });
      
      if (response.ok) {
        setShowAddModal(false);
        setNewConcept({ name: '', description: '', category: '' });
        loadConceptWeb(userName);
      }
    } catch (error) {
      console.error('Error adding concept:', error);
    }
  };

  const deleteConcept = async (nodeId) => {
    if (!window.confirm('Delete this concept?')) return;
    
    try {
      const token = localStorage.getItem('token');
      await fetch(`${API_URL}/delete_concept_node/${nodeId}`, {
        method: 'DELETE',
        headers: { 'Authorization': `Bearer ${token}` }
      });
      loadConceptWeb(userName);
      setSelectedNode(null);
    } catch (error) {
      console.error('Error deleting:', error);
    }
  };

  const deleteAllConcepts = async () => {
    if (!window.confirm('Delete ALL concepts? This cannot be undone!')) return;
    
    try {
      const token = localStorage.getItem('token');
      const response = await fetch(`${API_URL}/delete_all_concepts?user_id=${userName}`, {
        method: 'DELETE',
        headers: { 'Authorization': `Bearer ${token}` }
      });
      
      if (response.ok) {
        setConcepts([]);
        setConnections([]);
        setSelectedNode(null);
        setNodePositions({});
        alert('All concepts deleted successfully');
      }
    } catch (error) {
      console.error('Error deleting all:', error);
      alert('Failed to delete all concepts');
    }
  };

  const getMasteryColor = (level) => {
    if (level < 0.3) return '#EF4444';
    if (level < 0.7) return '#F59E0B';
    return '#10B981';
  };

  // Get vibrant color for node based on category with smart grouping
  const getCategoryColor = (category) => {
    const categoryLower = category.toLowerCase();
    
    // Group similar categories with same color family
    const colorGroups = {
      // Computer Science & Programming - Blue shades
      'algorithms': '#3B82F6',
      'sorting algorithms': '#3B82F6',
      'searching algorithms': '#2563EB',
      'graph algorithms': '#1D4ED8',
      'data structures': '#60A5FA',
      'machine learning': '#93C5FD',
      'web development': '#DBEAFE',
      'computer science': '#3B82F6',
      'programming': '#3B82F6',
      
      // Mathematics - Purple shades
      'mathematics': '#8B5CF6',
      'calculus': '#7C3AED',
      'linear algebra': '#6D28D9',
      'discrete math': '#A78BFA',
      'statistics': '#C4B5FD',
      'probability': '#DDD6FE',
      
      // Physics - Cyan shades
      'physics': '#06B6D4',
      'classical mechanics': '#0891B2',
      'quantum mechanics': '#0E7490',
      'thermodynamics': '#22D3EE',
      'electromagnetism': '#67E8F9',
      'newtons laws': '#06B6D4',
      'mechanics': '#0891B2',
      
      // Chemistry - Green shades
      'chemistry': '#10B981',
      'organic chemistry': '#059669',
      'inorganic chemistry': '#047857',
      'biochemistry': '#34D399',
      'physical chemistry': '#6EE7B7',
      
      // Biology - Emerald shades
      'biology': '#22C55E',
      'molecular biology': '#16A34A',
      'genetics': '#15803D',
      'cell biology': '#4ADE80',
      'neuroscience': '#86EFAC',
      'ecology': '#BBF7D0',
      
      // History & Social - Orange shades
      'history': '#F59E0B',
      'world history': '#D97706',
      'ancient history': '#B45309',
      'modern history': '#FBBF24',
      
      // Literature & Arts - Pink shades
      'literature': '#EC4899',
      'poetry': '#DB2777',
      'drama': '#BE185D',
      'art': '#F43F5E',
      'music': '#D946EF',
      
      // Philosophy & Psychology - Indigo shades
      'philosophy': '#6366F1',
      'psychology': '#4F46E5',
      'ethics': '#4338CA',
      'logic': '#818CF8',
      
      // Sports & Physical - Red shades
      'sports': '#EF4444',
      'fitness': '#DC2626',
      'athletics': '#B91C1C',
      
      // General & Others - Gold
      'general': '#D7B38C',
      'discussion': '#C4A57B',
      'academic': '#B8956A'
    };
    
    // Check for exact match or partial match
    for (const [key, color] of Object.entries(colorGroups)) {
      if (categoryLower === key || categoryLower.includes(key) || key.includes(categoryLower)) {
        return color;
      }
    }
    
    // Fallback: generate consistent color based on category name
    const vibrantPalette = [
      '#3B82F6', '#8B5CF6', '#06B6D4', '#10B981', '#22C55E',
      '#F59E0B', '#EC4899', '#6366F1', '#EF4444', '#14B8A6',
      '#0EA5E9', '#F43F5E', '#D946EF', '#84CC16', '#D7B38C',
      '#7C3AED', '#0891B2', '#059669', '#D97706', '#DB2777'
    ];
    
    let hash = 0;
    for (let i = 0; i < category.length; i++) {
      hash = category.charCodeAt(i) + ((hash << 5) - hash);
    }
    return vibrantPalette[Math.abs(hash) % vibrantPalette.length];
  };

  const getConnectionColor = (type, strength = 0.5) => {
    const baseColors = {
      prerequisite: { r: 251, g: 146, b: 60 },   // Vibrant Orange
      related: { r: 234, g: 179, b: 8 },         // Vibrant Gold
      opposite: { r: 239, g: 68, b: 68 },        // Vibrant Red
      example_of: { r: 34, g: 197, b: 94 },      // Vibrant Green
      part_of: { r: 59, g: 130, b: 246 },        // Vibrant Blue
      similar: { r: 168, g: 85, b: 247 }         // Vibrant Purple
    };
    
    const color = baseColors[type] || baseColors.related;
    const alpha = 0.4 + (strength * 0.5); // 0.4 to 0.9 opacity based on strength
    
    return `rgba(${color.r}, ${color.g}, ${color.b}, ${alpha})`;
  };
  
  const getConnectionWidth = (strength = 0.5) => {
    return 1 + (strength * 2); // 1px to 3px based on strength
  };

  const getConnectedConcepts = (conceptId) => {
    return connections.filter(conn => 
      conn.source_id === conceptId || conn.target_id === conceptId
    );
  };

  const getCategories = () => {
    const categories = new Set(concepts.map(c => c.category));
    return ['all', ...Array.from(categories)];
  };

  const getFilteredAndSortedConcepts = () => {
    let filtered = concepts;

    if (searchQuery) {
      filtered = filtered.filter(c => 
        c.concept_name.toLowerCase().includes(searchQuery.toLowerCase()) ||
        c.description?.toLowerCase().includes(searchQuery.toLowerCase()) ||
        c.category.toLowerCase().includes(searchQuery.toLowerCase())
      );
    }

    if (filterCategory !== 'all') {
      filtered = filtered.filter(c => c.category === filterCategory);
    }

    filtered.sort((a, b) => {
      switch (sortBy) {
        case 'name':
          return a.concept_name.localeCompare(b.concept_name);
        case 'mastery':
          return b.mastery_level - a.mastery_level;
        case 'connections':
          return getConnectedConcepts(b.id).length - getConnectedConcepts(a.id).length;
        case 'content':
          const aTotal = a.notes_count + a.quizzes_count + a.flashcards_count;
          const bTotal = b.notes_count + b.quizzes_count + b.flashcards_count;
          return bTotal - aTotal;
        default:
          return 0;
      }
    });

    return filtered;
  };

  const getStats = () => {
    const totalConcepts = concepts.length;
    const totalConnections = connections.length;
    const avgMastery = concepts.length > 0 
      ? Math.round((concepts.reduce((sum, c) => sum + c.mastery_level, 0) / concepts.length) * 100)
      : 0;
    const categories = new Set(concepts.map(c => c.category)).size;
    
    const masteryDistribution = {
      beginner: concepts.filter(c => c.mastery_level < 0.3).length,
      intermediate: concepts.filter(c => c.mastery_level >= 0.3 && c.mastery_level < 0.7).length,
      advanced: concepts.filter(c => c.mastery_level >= 0.7).length
    };

    const mostConnected = concepts.length > 0 
      ? concepts.reduce((max, c) => {
          const connCount = getConnectedConcepts(c.id).length;
          return connCount > (max.count || 0) ? { concept: c, count: connCount } : max;
        }, {})
      : null;

    const totalContent = concepts.reduce((sum, c) => 
      sum + c.notes_count + c.quizzes_count + c.flashcards_count, 0
    );
    
    return { 
      totalConcepts, 
      totalConnections, 
      avgMastery, 
      categories,
      masteryDistribution,
      mostConnected,
      totalContent
    };
  };

  const toggleConceptSelection = (conceptId) => {
    const newSelected = new Set(selectedConcepts);
    if (newSelected.has(conceptId)) {
      newSelected.delete(conceptId);
    } else {
      newSelected.add(conceptId);
    }
    setSelectedConcepts(newSelected);
  };

  const selectAll = () => {
    setSelectedConcepts(new Set(getFilteredAndSortedConcepts().map(c => c.id)));
  };

  const deselectAll = () => {
    setSelectedConcepts(new Set());
  };

  const deleteSelected = async () => {
    if (selectedConcepts.size === 0) return;
    if (!window.confirm(`Delete ${selectedConcepts.size} selected concepts?`)) return;

    try {
      const token = localStorage.getItem('token');
      await Promise.all(
        Array.from(selectedConcepts).map(id =>
          fetch(`${API_URL}/delete_concept_node/${id}`, {
            method: 'DELETE',
            headers: { 'Authorization': `Bearer ${token}` }
          })
        )
      );
      loadConceptWeb(userName);
      setSelectedConcepts(new Set());
      setSelectedNode(null);
    } catch (error) {
      console.error('Error deleting selected:', error);
    }
  };

  const generateConceptContent = async (contentType) => {
    if (!selectedNode) return;
    
    const contentNames = {
      notes: 'study notes',
      flashcards: 'flashcards',
      quiz: 'practice quiz'
    };
    
    const endpoints = {
      notes: 'generate_concept_notes',
      flashcards: 'generate_concept_flashcards',
      quiz: 'generate_concept_quiz'
    };
    
    if (!window.confirm(`Generate AI-powered ${contentNames[contentType]} for "${selectedNode.concept_name}"?`)) {
      return;
    }
    
    try {
      setGeneratingContent(contentType);
      const token = localStorage.getItem('token');
      const response = await fetch(`${API_URL}/${endpoints[contentType]}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${token}`
        },
        body: JSON.stringify({
          user_id: userName,
          concept_id: selectedNode.id
        })
      });
      
      if (response.ok) {
        const data = await response.json();
        alert(`✅ Generated ${contentNames[contentType]}! Mastery increased to ${Math.round(data.new_mastery * 100)}%`);
        
        await loadConceptWeb(userName);
        
        if (contentType === 'notes' && data.note_id) {
          navigate(`/notes`);
        } else if (contentType === 'flashcards' && data.set_id) {
          navigate(`/flashcards`);
        } else if (contentType === 'quiz' && data.quiz_id) {
          navigate(`/quiz-hub`);
        }
      } else {
        const error = await response.json();
        alert(`Failed to generate content: ${error.detail}`);
      }
    } catch (error) {
      console.error('Error generating content:', error);
      alert('Failed to generate content');
    } finally {
      setGeneratingContent(null);
    }
  };

  const exportData = () => {
    const data = {
      concepts: concepts.map(c => ({
        name: c.concept_name,
        category: c.category,
        description: c.description,
        mastery: c.mastery_level,
        content: {
          notes: c.notes_count,
          quizzes: c.quizzes_count,
          flashcards: c.flashcards_count
        }
      })),
      connections: connections.map(c => {
        const source = concepts.find(con => con.id === c.source_id);
        const target = concepts.find(con => con.id === c.target_id);
        return {
          from: source?.concept_name,
          to: target?.concept_name,
          type: c.connection_type,
          strength: c.strength
        };
      }),
      stats: getStats(),
      exportDate: new Date().toISOString()
    };

    const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `concept-web-${new Date().toISOString().split('T')[0]}.json`;
    a.click();
    URL.revokeObjectURL(url);
  };

  // Drag and drop functionality
  const handleMouseDown = (e, conceptId) => {
    if (e.button !== 0) return;
    e.stopPropagation();
    
    const svg = svgRef.current;
    if (!svg) return;
    
    const rect = svg.getBoundingClientRect();
    const svgX = ((e.clientX - rect.left) / rect.width) * 100;
    const svgY = ((e.clientY - rect.top) / rect.height) * 100;
    
    const pos = nodePositions[conceptId];
    if (pos) {
      setDraggingNode(conceptId);
      setDragOffset({
        x: svgX - pos.x,
        y: svgY - pos.y
      });
    }
  };

  const handleMouseMove = useCallback((e) => {
    if (!draggingNode || !svgRef.current) return;
    
    const svg = svgRef.current;
    const rect = svg.getBoundingClientRect();
    const svgX = ((e.clientX - rect.left) / rect.width) * 100;
    const svgY = ((e.clientY - rect.top) / rect.height) * 100;
    
    setNodePositions(prev => ({
      ...prev,
      [draggingNode]: {
        ...prev[draggingNode],
        x: Math.max(5, Math.min(95, svgX - dragOffset.x)),
        y: Math.max(5, Math.min(95, svgY - dragOffset.y))
      }
    }));
  }, [draggingNode, dragOffset]);

  const handleMouseUp = useCallback(() => {
    setDraggingNode(null);
  }, []);

  useEffect(() => {
    if (draggingNode) {
      window.addEventListener('mousemove', handleMouseMove);
      window.addEventListener('mouseup', handleMouseUp);
      return () => {
        window.removeEventListener('mousemove', handleMouseMove);
        window.removeEventListener('mouseup', handleMouseUp);
      };
    }
  }, [draggingNode, handleMouseMove, handleMouseUp]);

  // Fullscreen toggle
  const toggleFullscreen = () => {
    setIsFullscreen(!isFullscreen);
  };

  // Reset positions
  const resetPositions = () => {
    setNodePositions(initializeNodePositions(concepts));
  };

  const [sidebarCollapsed, setSidebarCollapsed] = useState(false);

  // Icons for sidebar
  const Icons = {
    network: <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><circle cx="12" cy="5" r="3"/><circle cx="5" cy="19" r="3"/><circle cx="19" cy="19" r="3"/><line x1="12" y1="8" x2="5" y2="16"/><line x1="12" y1="8" x2="19" y2="16"/></svg>,
    grid: <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><rect x="3" y="3" width="7" height="7"/><rect x="14" y="3" width="7" height="7"/><rect x="3" y="14" width="7" height="7"/><rect x="14" y="14" width="7" height="7"/></svg>,
    chart: <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M18 20V10"/><path d="M12 20V4"/><path d="M6 20v-6"/></svg>,
    home: <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"/><polyline points="9 22 9 12 15 12 15 22"/></svg>,
    chat: <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"/></svg>,
    logout: <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4"/><polyline points="16 17 21 12 16 7"/><line x1="21" y1="12" x2="9" y2="12"/></svg>,
  };

  return (
    <div className={`concept-web-page ${isFullscreen ? 'fullscreen' : ''}`}>
      <div className="cw-layout">
        {/* Sidebar */}
        <aside className={`cw-sidebar ${sidebarCollapsed ? 'collapsed' : ''}`}>
          <div className="cw-sidebar-header">
            <div className="cw-logo" onClick={() => navigate('/dashboard')}>
              <div className="cw-logo-icon">
                <Brain size={22} />
              </div>
              <span className="cw-logo-text">cerbyl</span>
            </div>
            <button className="cw-collapse-btn" onClick={() => setSidebarCollapsed(!sidebarCollapsed)}>
              {sidebarCollapsed ? '›' : '‹'}
            </button>
          </div>

          <nav className="cw-sidebar-nav">
            <button className={`cw-nav-item ${viewMode === 'network' ? 'active' : ''}`} onClick={() => setViewMode('network')}>
              <span className="cw-nav-icon">{Icons.network}</span>
              <span className="cw-nav-text">Network View</span>
            </button>
            <button className={`cw-nav-item ${viewMode === 'grid' ? 'active' : ''}`} onClick={() => setViewMode('grid')}>
              <span className="cw-nav-icon">{Icons.grid}</span>
              <span className="cw-nav-text">Grid View</span>
            </button>
            <button className={`cw-nav-item ${showAnalytics ? 'active' : ''}`} onClick={() => setShowAnalytics(!showAnalytics)}>
              <span className="cw-nav-icon">{Icons.chart}</span>
              <span className="cw-nav-text">Analytics</span>
            </button>
          </nav>

          <div className="cw-sidebar-footer">
            <button className="cw-nav-item" onClick={() => navigate('/dashboard')}>
              <span className="cw-nav-icon">{Icons.home}</span>
              <span className="cw-nav-text">Dashboard</span>
            </button>
            <button className="cw-nav-item" onClick={() => navigate('/ai-chat')}>
              <span className="cw-nav-icon">{Icons.chat}</span>
              <span className="cw-nav-text">AI Chat</span>
            </button>
            <button className="cw-nav-item" onClick={() => { localStorage.clear(); navigate('/login'); }}>
              <span className="cw-nav-icon">{Icons.logout}</span>
              <span className="cw-nav-text">Logout</span>
            </button>
          </div>
        </aside>

        {/* Show Sidebar Button */}
        {sidebarCollapsed && (
          <button className="cw-show-sidebar-btn" onClick={() => setSidebarCollapsed(false)} title="Show Sidebar">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" width="20" height="20">
              <line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="18" x2="21" y2="18"/>
            </svg>
          </button>
        )}

        {/* Main Content */}
        <main className="cw-main">
          <header className="cw-header">
            <div className="cw-header-left">
              <h1 className="cw-header-title">Concept Web</h1>
              <p className="cw-header-subtitle">Your Knowledge Universe</p>
            </div>
            <div className="cw-header-actions">
              {concepts.length > 0 && (
                <div className="cw-stats-bar">
                  <div className="cw-stat-mini">
                    <span className="cw-stat-value">{getStats().totalConcepts}</span>
                    <span className="cw-stat-label">Concepts</span>
                  </div>
                  <div className="cw-stat-mini">
                    <span className="cw-stat-value">{getStats().totalConnections}</span>
                    <span className="cw-stat-label">Links</span>
                  </div>
                  <div className="cw-stat-mini">
                    <span className="cw-stat-value">{getStats().avgMastery}%</span>
                    <span className="cw-stat-label">Mastery</span>
                  </div>
                </div>
              )}
              {viewMode === 'network' && concepts.length > 0 && (
                <>
                  <button className="cw-icon-btn" onClick={resetPositions} title="Reset Layout">
                    <Move size={18} />
                  </button>
                  <button className="cw-icon-btn" onClick={toggleFullscreen} title={isFullscreen ? 'Exit Fullscreen' : 'Fullscreen'}>
                    {isFullscreen ? <Minimize2 size={18} /> : <Maximize2 size={18} />}
                  </button>
                </>
              )}
              <button className="cw-icon-btn" onClick={exportData} title="Export">
                <Download size={18} />
              </button>
              <button 
                className="cw-icon-btn" 
                onClick={async () => {
                  if (!window.confirm('Regenerate concept web from your latest content?')) return;
                  setGenerating(true);
                  const token = localStorage.getItem('token');
                  try {
                    await fetch(`${API_URL}/generate_concept_web`, {
                      method: 'POST',
                      headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${token}` },
                      body: JSON.stringify({ user_id: userName })
                    });
                    await loadConceptWeb(userName, false);
                  } finally {
                    setGenerating(false);
                  }
                }}
                title="Regenerate"
                disabled={generating}
              >
                {generating ? <Loader size={18} className="cw-spinner" /> : <RefreshCw size={18} />}
              </button>
              <button className="cw-btn cw-btn-primary" onClick={() => setShowAddModal(true)}>
                <Plus size={16} />
                <span>Add Concept</span>
              </button>
            </div>
          </header>

          <div className="cw-content" ref={containerRef}>
            {loading && initialLoad ? (
              <div className="cw-loading">
                <Loader size={32} className="cw-spinner" />
                <p className="cw-loading-text">Loading your knowledge universe...</p>
              </div>
            ) : concepts.length === 0 ? (
              <div className="cw-empty">
                <div className="cw-empty-icon">
                  <Brain size={48} />
                </div>
                <h3 className="cw-empty-title">No Concepts Yet</h3>
                <p className="cw-empty-text">Start building your knowledge web by adding concepts or generating from your content</p>
                <div className="cw-empty-actions">
                  <button className="cw-btn cw-btn-primary" onClick={() => setShowAddModal(true)}>
                    <Plus size={18} />
                    Add Concept
                  </button>
                </div>
              </div>
            ) : (
              <>
                {/* Analytics Panel */}
                {showAnalytics && (
                  <div className="cw-analytics-panel">
                    <div className="cw-analytics-header">
                      <h3 className="cw-analytics-title">Analytics</h3>
                      <button className="cw-detail-close" onClick={() => setShowAnalytics(false)}>×</button>
                    </div>
                    <div className="cw-analytics-content">
                      <div className="cw-analytics-grid">
                        <div className="cw-analytics-card">
                          <span className="cw-analytics-value">{getStats().totalConcepts}</span>
                          <span className="cw-analytics-label">Concepts</span>
                        </div>
                        <div className="cw-analytics-card">
                          <span className="cw-analytics-value">{getStats().totalConnections}</span>
                          <span className="cw-analytics-label">Links</span>
                        </div>
                        <div className="cw-analytics-card">
                          <span className="cw-analytics-value">{getStats().avgMastery}%</span>
                          <span className="cw-analytics-label">Avg Mastery</span>
                        </div>
                        <div className="cw-analytics-card">
                          <span className="cw-analytics-value">{getStats().categories}</span>
                          <span className="cw-analytics-label">Categories</span>
                        </div>
                      </div>
                      <div className="cw-mastery-distribution">
                        <div className="cw-mastery-item">
                          <span className="cw-mastery-label">Beginner</span>
                          <div className="cw-mastery-bar-container">
                            <div className="cw-mastery-bar-fill beginner" style={{ width: `${(getStats().masteryDistribution.beginner / concepts.length) * 100}%` }}></div>
                          </div>
                          <span className="cw-mastery-count">{getStats().masteryDistribution.beginner}</span>
                        </div>
                        <div className="cw-mastery-item">
                          <span className="cw-mastery-label">Intermediate</span>
                          <div className="cw-mastery-bar-container">
                            <div className="cw-mastery-bar-fill intermediate" style={{ width: `${(getStats().masteryDistribution.intermediate / concepts.length) * 100}%` }}></div>
                          </div>
                          <span className="cw-mastery-count">{getStats().masteryDistribution.intermediate}</span>
                        </div>
                        <div className="cw-mastery-item">
                          <span className="cw-mastery-label">Advanced</span>
                          <div className="cw-mastery-bar-container">
                            <div className="cw-mastery-bar-fill advanced" style={{ width: `${(getStats().masteryDistribution.advanced / concepts.length) * 100}%` }}></div>
                          </div>
                          <span className="cw-mastery-count">{getStats().masteryDistribution.advanced}</span>
                        </div>
                      </div>
                    </div>
                  </div>
                )}

                {/* View Mode: Network or Grid */}
                {viewMode === 'network' ? (
                  <div className="cw-network-container">
                        <svg 
                      ref={svgRef}
                      className="cw-network-svg" 
                  viewBox={`${50 - (50 / zoomLevel) + panOffset.x} ${50 - (50 / zoomLevel) + panOffset.y} ${100 / zoomLevel} ${100 / zoomLevel}`}
                  preserveAspectRatio="xMidYMid meet"
                  onMouseDown={handlePanStart}
                  style={{ cursor: isPanning ? 'grabbing' : 'grab' }}
                >
                  {/* Gradient Definitions */}
                  <defs>
                    {/* Create a glow gradient for each unique category */}
                    {Array.from(new Set(concepts.map(c => c.category))).map(category => (
                      <radialGradient key={category} id={`nodeGlow-${category.replace(/\s+/g, '-')}`} cx="50%" cy="50%" r="50%">
                        <stop offset="0%" stopColor={getCategoryColor(category)} stopOpacity="0.4" />
                        <stop offset="100%" stopColor={getCategoryColor(category)} stopOpacity="0" />
                      </radialGradient>
                    ))}
                    <filter id="glow">
                      <feGaussianBlur stdDeviation="0.5" result="coloredBlur"/>
                      <feMerge>
                        <feMergeNode in="coloredBlur"/>
                        <feMergeNode in="SourceGraphic"/>
                      </feMerge>
                    </filter>
                  </defs>

                  {/* Draw connections */}
                  <g className="connections-layer">
                    {connections.map((conn, idx) => {
                      const source = concepts.find(c => c.id === conn.source_id);
                      const target = concepts.find(c => c.id === conn.target_id);
                      if (!source || !target || !nodePositions[source.id] || !nodePositions[target.id]) return null;

                      const sourcePos = nodePositions[source.id];
                      const targetPos = nodePositions[target.id];

                      const isHighlighted = hoveredNode && 
                        (hoveredNode === source.id || hoveredNode === target.id);
                      
                      const isSelected = selectedNode && 
                        (selectedNode.id === source.id || selectedNode.id === target.id);
                      
                      const strength = conn.strength || 0.5;
                      const connectionColor = getConnectionColor(conn.connection_type, strength);
                      const strokeWidth = getConnectionWidth(strength);

                      return (
                        <g key={`conn-${source.id}-${target.id}-${sourcePos.x}-${sourcePos.y}-${targetPos.x}-${targetPos.y}`}>
                          {/* Glow effect for highlighted connections */}
                          {(isHighlighted || isSelected) && (
                            <line
                              x1={sourcePos.x}
                              y1={sourcePos.y}
                              x2={targetPos.x}
                              y2={targetPos.y}
                              stroke={connectionColor}
                              strokeWidth={strokeWidth * 0.3}
                              strokeOpacity={0.3}
                              className="connection-glow"
                              style={{
                                filter: 'blur(3px)'
                              }}
                            />
                          )}
                          
                          {/* Main connection line - ALWAYS VISIBLE */}
                          <line
                            x1={sourcePos.x}
                            y1={sourcePos.y}
                            x2={targetPos.x}
                            y2={targetPos.y}
                            stroke={isHighlighted || isSelected ? connectionColor : connectionColor}
                            strokeWidth={isHighlighted || isSelected ? strokeWidth * 0.15 : strokeWidth * 0.1}
                            strokeOpacity={isHighlighted || isSelected ? 0.95 : 0.6}
                            className="connection-line-ethereal"
                            strokeDasharray={conn.connection_type === 'prerequisite' ? '0.4,0.4' : 'none'}
                            style={{
                              transition: 'all 0.3s cubic-bezier(0.4, 0, 0.2, 1)'
                            }}
                          />
                          
                          {/* Connection strength indicator (thicker line for stronger connections) */}
                          {strength > 0.7 && (isHighlighted || isSelected) && (
                            <line
                              x1={sourcePos.x}
                              y1={sourcePos.y}
                              x2={targetPos.x}
                              y2={targetPos.y}
                              stroke={connectionColor}
                              strokeWidth={0.05}
                              strokeOpacity={0.4}
                              strokeDasharray="0.2,0.2"
                            />
                          )}
                        </g>
                      );
                    })}
                  </g>

                  {/* Draw nodes */}
                  <g className="nodes-layer">
                    {concepts.map((concept) => {
                      if (!nodePositions[concept.id]) return null;
                      
                      const pos = nodePositions[concept.id];
                      const isSelected = selectedNode?.id === concept.id;
                      const isHovered = hoveredNode === concept.id;
                      const connectedConcepts = getConnectedConcepts(concept.id);
                      const nodeSize = isHovered ? 1.8 : isSelected ? 1.65 : 1.5;

                      return (
                        <g 
                          key={concept.id}
                          className={`network-node-ethereal ${isSelected ? 'selected' : ''} ${isHovered ? 'hovered' : ''}`}
                          onMouseEnter={() => setHoveredNode(concept.id)}
                          onMouseLeave={() => setHoveredNode(null)}
                          onClick={() => setSelectedNode(concept)}
                          onMouseDown={(e) => handleMouseDown(e, concept.id)}
                          style={{ cursor: draggingNode === concept.id ? 'grabbing' : 'grab' }}
                        >
                          {/* Glow effect */}
                          {(isHovered || isSelected) && (
                            <circle
                              cx={pos.x}
                              cy={pos.y}
                              r={nodeSize * 2.5}
                              fill={`url(#nodeGlow-${concept.category.replace(/\s+/g, '-')})`}
                              className="node-glow"
                            />
                          )}
                          
                          {/* Main node circle */}
                          <circle
                            cx={pos.x}
                            cy={pos.y}
                            r={nodeSize}
                            fill={getCategoryColor(concept.category)}
                            stroke={isSelected ? getCategoryColor(concept.category) : '#4A4A4A'}
                            strokeWidth={isSelected ? 0.3 : 0.15}
                            className="node-circle-ethereal"
                            filter={isHovered || isSelected ? 'url(#glow)' : ''}
                            style={{ opacity: concept.mastery_level < 0.3 ? 0.6 : concept.mastery_level < 0.7 ? 0.8 : 1 }}
                          />
                          
                          {/* Node label */}
                          <text
                            x={pos.x}
                            y={pos.y - nodeSize - 0.8}
                            textAnchor="middle"
                            fill="var(--text-primary)"
                            fontSize="1.1"
                            fontWeight="700"
                            className="node-label-ethereal"
                            style={{ pointerEvents: 'none' }}
                          >
                            {concept.concept_name.length > 12 
                              ? concept.concept_name.substring(0, 12) + '...' 
                              : concept.concept_name}
                          </text>
                          
                          {/* Connection count badge */}
                          {connectedConcepts.length > 0 && (
                            <g>
                              <circle
                                cx={pos.x + nodeSize * 0.7}
                                cy={pos.y - nodeSize * 0.7}
                                r="0.65"
                                fill="var(--accent)"
                                stroke="var(--bg-bottom)"
                                strokeWidth="0.12"
                              />
                              <text
                                x={pos.x + nodeSize * 0.7}
                                y={pos.y - nodeSize * 0.7 + 0.35}
                                textAnchor="middle"
                                fill="var(--bg-bottom)"
                                fontSize="0.75"
                                fontWeight="800"
                                style={{ pointerEvents: 'none' }}
                              >
                                {connectedConcepts.length}
                              </text>
                            </g>
                          )}
                        </g>
                      );
                    })}
                  </g>
                </svg>

                {/* Hover Tooltip */}
                {hoveredNode && (
                  <div 
                    className="hover-tooltip-ethereal"
                    style={(() => {
                      const concept = concepts.find(c => c.id === hoveredNode);
                      if (!concept || !nodePositions[concept.id]) return {};
                      
                      const pos = nodePositions[concept.id];
                      const isLeftSide = pos.x < 50;
                      
                      if (isLeftSide) {
                        // Left side nodes - show tooltip on left, below legend
                        const bottomVariations = [40, 50, 60, 70, 80];
                        const randomBottom = bottomVariations[Math.floor(Math.random() * bottomVariations.length)];
                        return {
                          left: '40px',
                          bottom: `${randomBottom}px`
                        };
                      } else {
                        // Right side nodes - show tooltip on right
                        const topVariations = [120, 150, 180, 210, 240];
                        const randomTop = topVariations[Math.floor(Math.random() * topVariations.length)];
                        return {
                          right: '40px',
                          top: `${randomTop}px`
                        };
                      }
                    })()}
                  >
                    {(() => {
                      const concept = concepts.find(c => c.id === hoveredNode);
                      if (!concept) return null;
                      
                      return (
                        <>
                          <div className="tooltip-header">
                            <h4>{concept.concept_name}</h4>
                            <span className="tooltip-category">{concept.category}</span>
                          </div>
                          {concept.description && (
                            <p className="tooltip-description">{concept.description}</p>
                          )}
                          <div className="tooltip-stats">
                            <div className="tooltip-stat">
                              <span className="tooltip-stat-label">MASTERY</span>
                              <span className="tooltip-stat-value" style={{ color: getMasteryColor(concept.mastery_level) }}>
                                {Math.round(concept.mastery_level * 100)}%
                              </span>
                            </div>
                            <div className="tooltip-stat">
                              <span className="tooltip-stat-label">CONNECTIONS</span>
                              <span className="tooltip-stat-value">
                                {getConnectedConcepts(concept.id).length}
                              </span>
                            </div>
                          </div>
                          <div className="tooltip-content-grid">
                            <div className="tooltip-content-item">
                              <FileText size={14} />
                              <span>{concept.notes_count}</span>
                            </div>
                            <div className="tooltip-content-item">
                              <Brain size={14} />
                              <span>{concept.quizzes_count}</span>
                            </div>
                            <div className="tooltip-content-item">
                              <BookOpen size={14} />
                              <span>{concept.flashcards_count}</span>
                            </div>
                          </div>
                          <div className="tooltip-hint">
                            <Info size={12} />
                            <span>Click to view details • Drag to move</span>
                          </div>
                        </>
                      );
                    })()}
                  </div>
                )}

                {/* Network Controls */}
                <div className="network-controls-ethereal">
                  <div className="control-hint">
                    <Move size={14} />
                    <span>Drag nodes to reposition</span>
                  </div>
                  
                  {/* Zoom Controls */}
                  <div className="zoom-controls-ethereal">
                    <div className="zoom-buttons">
                      <button 
                        className="zoom-btn" 
                        onClick={() => setZoomLevel(Math.min(zoomLevel + 0.2, 5))}
                        title="Zoom In"
                      >
                        +
                      </button>
                      <span className="zoom-level">{Math.round(zoomLevel * 100)}%</span>
                      <button 
                        className="zoom-btn" 
                        onClick={() => setZoomLevel(Math.max(zoomLevel - 0.2, 0.3))}
                        title="Zoom Out"
                      >
                        −
                      </button>
                      <button 
                        className="zoom-btn" 
                        onClick={() => {
                          setZoomLevel(1);
                          setPanOffset({ x: 0, y: 0 });
                        }}
                        title="Reset View"
                      >
                        ⟲
                      </button>
                    </div>
                    <div className="zoom-hint">
                      Pinch or Ctrl+Scroll to zoom
                    </div>
                  </div>
                  
                  {concepts.length > 0 && (
                    <>
                      <div className="color-legend-ethereal">
                        <div className="legend-title">CATEGORIES</div>
                        {Array.from(new Set(concepts.map(c => c.category))).slice(0, 6).map(category => (
                          <div key={category} className="legend-item">
                            <div 
                              className="legend-color" 
                              style={{ backgroundColor: getCategoryColor(category) }}
                            ></div>
                            <span>{category}</span>
                          </div>
                        ))}
                      </div>
                      
                      {connections.length > 0 && (
                        <div className="color-legend-ethereal" style={{ marginTop: '12px' }}>
                          <div className="legend-title">CONNECTIONS</div>
                          <div className="legend-item">
                            <div className="legend-line" style={{ 
                              background: getConnectionColor('prerequisite', 0.7),
                              borderStyle: 'dashed'
                            }}></div>
                            <span>Prerequisite</span>
                          </div>
                          <div className="legend-item">
                            <div className="legend-line" style={{ 
                              background: getConnectionColor('related', 0.7)
                            }}></div>
                            <span>Related</span>
                          </div>
                          <div className="legend-item">
                            <div className="legend-line" style={{ 
                              background: getConnectionColor('similar', 0.7)
                            }}></div>
                            <span>Similar</span>
                          </div>
                          <div className="legend-item">
                            <div className="legend-line" style={{ 
                              background: getConnectionColor('part_of', 0.7)
                            }}></div>
                            <span>Part Of</span>
                          </div>
                        </div>
                      )}
                    </>
                  )}
                </div>
              </div>
                ) : (
                  // Grid View
                  <div className="cw-grid-container">
                    {/* Search and Filters */}
                    <div className="cw-toolbar">
                      <div className="cw-search">
                        <span className="cw-search-icon"><Search size={16} /></span>
                        <input
                          type="text"
                          placeholder="Search concepts..."
                          value={searchQuery}
                          onChange={(e) => setSearchQuery(e.target.value)}
                        />
                      </div>
                      
                      <select className="cw-select" value={filterCategory} onChange={(e) => setFilterCategory(e.target.value)}>
                        {getCategories().map(cat => (
                          <option key={cat} value={cat}>{cat === 'all' ? 'All Categories' : cat}</option>
                        ))}
                      </select>

                      <select className="cw-select" value={sortBy} onChange={(e) => setSortBy(e.target.value)}>
                        <option value="name">Sort by Name</option>
                        <option value="mastery">Sort by Mastery</option>
                        <option value="connections">Sort by Connections</option>
                        <option value="content">Sort by Content</option>
                      </select>
                    </div>

                    {/* Concept Cards Grid */}
                    <div className="cw-grid">
                      {getFilteredAndSortedConcepts().map((concept) => {
                        const connectedConcepts = getConnectedConcepts(concept.id);
                        const isSelected = selectedNode?.id === concept.id;

                        return (
                          <div 
                            key={concept.id}
                            className={`cw-card ${isSelected ? 'selected' : ''}`}
                            onClick={() => setSelectedNode(concept)}
                          >
                            <div className="cw-card-header">
                              <div className="cw-card-icon">
                                <Brain size={24} />
                              </div>
                              <div className="cw-card-actions">
                                <button 
                                  className="cw-card-action-btn delete"
                                  onClick={(e) => { e.stopPropagation(); deleteConcept(concept.id); }}
                                  title="Delete"
                                >
                                  <Trash2 size={14} />
                                </button>
                              </div>
                            </div>
                            <div className="cw-card-content">
                              <h3 className="cw-card-title">{concept.concept_name}</h3>
                              <span className="cw-card-category">{concept.category}</span>
                              {concept.description && (
                                <p className="cw-card-description">{concept.description}</p>
                              )}
                              <div className="cw-card-stats">
                                <div className="cw-card-stat">
                                  <span className="cw-card-stat-value">{Math.round(concept.mastery_level * 100)}%</span>
                                  <span className="cw-card-stat-label">Mastery</span>
                                </div>
                                <div className="cw-card-stat">
                                  <span className="cw-card-stat-value">{connectedConcepts.length}</span>
                                  <span className="cw-card-stat-label">Links</span>
                                </div>
                              </div>
                            </div>
                            <div className="cw-card-footer">
                              <div className="cw-mastery-bar">
                                <div className="cw-mastery-fill" style={{ width: `${concept.mastery_level * 100}%` }}></div>
                              </div>
                            </div>
                          </div>
                        );
                      })}
                </div>

                    {getFilteredAndSortedConcepts().length === 0 && (
                      <div className="cw-empty">
                        <Search size={48} />
                        <p className="cw-empty-text">No concepts match your search</p>
                      </div>
                    )}
                  </div>
                )}
              </>
            )}
          </div>

          {/* Detail Panel */}
          {selectedNode && (
            <div className="cw-detail-panel">
              <div className="cw-detail-header">
                <div>
                  <h3 className="cw-detail-title">{selectedNode.concept_name}</h3>
                  <span className="cw-detail-category">{selectedNode.category}</span>
                </div>
                <button className="cw-detail-close" onClick={() => setSelectedNode(null)}>×</button>
              </div>
              
              <div className="cw-detail-content">
                {selectedNode.description && (
                  <div className="cw-detail-section">
                    <h4 className="cw-detail-section-title">Description</h4>
                    <p className="cw-detail-description">{selectedNode.description}</p>
                  </div>
                )}

                <div className="cw-detail-section">
                  <h4 className="cw-detail-section-title">Mastery Level</h4>
                  <div className="cw-mastery-bar">
                    <div className="cw-mastery-fill" style={{ width: `${selectedNode.mastery_level * 100}%` }}></div>
                  </div>
                  <span style={{ fontSize: '14px', fontWeight: '600', color: 'var(--cw-accent)' }}>
                    {Math.round(selectedNode.mastery_level * 100)}%
                  </span>
                </div>

                <div className="cw-detail-section">
                  <h4 className="cw-detail-section-title">Statistics</h4>
                  <div className="cw-detail-stats-grid">
                    <div className="cw-detail-stat">
                      <span className="cw-detail-stat-value">{selectedNode.notes_count}</span>
                      <span className="cw-detail-stat-label">Notes</span>
                    </div>
                    <div className="cw-detail-stat">
                      <span className="cw-detail-stat-value">{selectedNode.quizzes_count}</span>
                      <span className="cw-detail-stat-label">Quizzes</span>
                    </div>
                    <div className="cw-detail-stat">
                      <span className="cw-detail-stat-value">{selectedNode.flashcards_count}</span>
                      <span className="cw-detail-stat-label">Flashcards</span>
                    </div>
                    <div className="cw-detail-stat">
                      <span className="cw-detail-stat-value">{getConnectedConcepts(selectedNode.id).length}</span>
                      <span className="cw-detail-stat-label">Links</span>
                    </div>
                  </div>
                </div>

                <div className="cw-detail-section">
                  <h4 className="cw-detail-section-title">Generate Content</h4>
                  <div className="cw-detail-actions">
                    <button 
                      className="cw-detail-action-btn"
                      onClick={() => generateConceptContent('notes')}
                      disabled={generatingContent !== null}
                    >
                      <FileText size={18} />
                      <span>{generatingContent === 'notes' ? 'Generating...' : 'Generate Notes'}</span>
                    </button>
                    <button 
                      className="cw-detail-action-btn"
                      onClick={() => generateConceptContent('quiz')}
                      disabled={generatingContent !== null}
                    >
                      <Brain size={18} />
                      <span>{generatingContent === 'quiz' ? 'Generating...' : 'Generate Quiz'}</span>
                    </button>
                    <button 
                      className="cw-detail-action-btn"
                      onClick={() => generateConceptContent('flashcards')}
                      disabled={generatingContent !== null}
                    >
                      <BookOpen size={18} />
                      <span>{generatingContent === 'flashcards' ? 'Generating...' : 'Generate Flashcards'}</span>
                    </button>
                  </div>
                </div>

                {getConnectedConcepts(selectedNode.id).length > 0 && (
                  <div className="cw-detail-section">
                    <h4 className="cw-detail-section-title">Connections</h4>
                    <div className="cw-connections-list">
                      {getConnectedConcepts(selectedNode.id).map(conn => {
                        const targetId = conn.source_id === selectedNode.id ? conn.target_id : conn.source_id;
                        const targetConcept = concepts.find(c => c.id === targetId);
                        if (!targetConcept) return null;
                        
                        return (
                          <div 
                            key={conn.id} 
                            className="cw-connection-item"
                            onClick={() => setSelectedNode(targetConcept)}
                          >
                            <span className="cw-connection-name">{targetConcept.concept_name}</span>
                            <span className="cw-connection-type">{conn.connection_type.replace('_', ' ')}</span>
                          </div>
                        );
                      })}
                    </div>
                  </div>
                )}

                <button 
                  className="cw-btn cw-btn-secondary" 
                  style={{ width: '100%', marginTop: '16px', color: 'var(--cw-danger)' }}
                  onClick={() => deleteConcept(selectedNode.id)}
                >
                  <Trash2 size={16} />
                  Delete Concept
                </button>
              </div>
            </div>
          )}

        </main>
      </div>

      {/* Add Concept Modal */}
      {showAddModal && (
        <div className="cw-modal-overlay" onClick={() => setShowAddModal(false)}>
          <div className="cw-modal" onClick={e => e.stopPropagation()}>
            <div className="cw-modal-header">
              <h3 className="cw-modal-title">Add New Concept</h3>
              <button className="cw-modal-close" onClick={() => setShowAddModal(false)}>×</button>
            </div>
            <div className="cw-modal-content">
              <div className="cw-form-group">
                <label className="cw-form-label">Concept Name *</label>
                <input
                  className="cw-form-input"
                  type="text"
                  value={newConcept.name}
                  onChange={e => setNewConcept({...newConcept, name: e.target.value})}
                  placeholder="e.g., Machine Learning"
                  autoFocus
                />
              </div>
              <div className="cw-form-group">
                <label className="cw-form-label">Category</label>
                <input
                  className="cw-form-input"
                  type="text"
                  value={newConcept.category}
                  onChange={e => setNewConcept({...newConcept, category: e.target.value})}
                  placeholder="e.g., Computer Science"
                />
              </div>
              <div className="cw-form-group">
                <label className="cw-form-label">Description</label>
                <textarea
                  className="cw-form-textarea"
                  value={newConcept.description}
                  onChange={e => setNewConcept({...newConcept, description: e.target.value})}
                  placeholder="Brief description of the concept..."
                  rows="4"
                />
              </div>
            </div>
            <div className="cw-modal-footer">
              <button className="cw-btn cw-btn-secondary" onClick={() => setShowAddModal(false)}>
                Cancel
              </button>
              <button className="cw-btn cw-btn-primary" onClick={addConcept}>
                <Plus size={16} />
                Add Concept
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
};

export default ConceptWeb;
