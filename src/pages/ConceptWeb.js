import React, { useState, useEffect, useRef, useCallback } from 'react';
import { useNavigate } from 'react-router-dom';
import { 
  Sparkles, Plus, Trash2, ArrowLeft, Loader, Link as LinkIcon, 
  BookOpen, FileText, Brain, Filter, Search, TrendingUp, Download, 
  Eye, EyeOff, Grid, Network, BarChart3, CheckSquare, Square, 
  Maximize2, Minimize2, RefreshCw, Zap, Target, Move, Info 
} from 'lucide-react';
import './ConceptWeb.css';
import { API_URL } from '../config';

const ConceptWeb = () => {
  const navigate = useNavigate();
  const [userName, setUserName] = useState('');
  const [concepts, setConcepts] = useState([]);
  const [connections, setConnections] = useState([]);
  const [loading, setLoading] = useState(true);
  const [initialLoad, setInitialLoad] = useState(true);
  const [generating, setGenerating] = useState(false);
  const [selectedNode, setSelectedNode] = useState(null);
  const [hoveredNode, setHoveredNode] = useState(null);
  const [showAddModal, setShowAddModal] = useState(false);
  const [newConcept, setNewConcept] = useState({ name: '', description: '', category: '' });
  const [searchQuery, setSearchQuery] = useState('');
  const [filterCategory, setFilterCategory] = useState('all');
  const [sortBy, setSortBy] = useState('name');
  const [viewMode, setViewMode] = useState('network');
  const [selectedConcepts, setSelectedConcepts] = useState(new Set());
  const [showAnalytics, setShowAnalytics] = useState(false);
  const [highlightConnections, setHighlightConnections] = useState(null);
  const [isPanelCollapsed, setIsPanelCollapsed] = useState(false);
  const [generatingContent, setGeneratingContent] = useState(null);
  const [nodePositions, setNodePositions] = useState({});
  const [draggingNode, setDraggingNode] = useState(null);
  const [dragOffset, setDragOffset] = useState({ x: 0, y: 0 });
  const [isFullscreen, setIsFullscreen] = useState(false);
  const [fadeIn, setFadeIn] = useState(false);
  const [autoGenerated, setAutoGenerated] = useState(false);
  const svgRef = useRef(null);
  const containerRef = useRef(null);

  // Initialize node positions in a beautiful circular layout
  const initializeNodePositions = useCallback((conceptsList) => {
    const positions = {};
    const centerX = 50;
    const centerY = 50;
    const radius = 35;
    const angleStep = (2 * Math.PI) / conceptsList.length;
    
    conceptsList.forEach((concept, index) => {
      const angle = index * angleStep - Math.PI / 2;
      const x = centerX + radius * Math.cos(angle);
      const y = centerY + radius * Math.sin(angle);
      
      positions[concept.id] = {
        x,
        y,
        vx: (Math.random() - 0.5) * 0.1,
        vy: (Math.random() - 0.5) * 0.1
      };
    });
    
    return positions;
  }, []);

  // Auto-load concept web on mount
  useEffect(() => {
    const token = localStorage.getItem('token');
    const username = localStorage.getItem('username');
    
    if (!token) {
      navigate('/login');
      return;
    }
    
    if (username) {
      setUserName(username);
      loadConceptWeb(username, true);
    }
  }, [navigate]);

  // Fade in animation after loading
  useEffect(() => {
    if (!loading && concepts.length > 0) {
      setTimeout(() => setFadeIn(true), 100);
    }
  }, [loading, concepts]);

  // Auto-generate if no concepts exist
  const loadConceptWeb = async (username, isInitial = false) => {
    try {
      setLoading(true);
      const token = localStorage.getItem('token');
      const response = await fetch(`${API_URL}/get_concept_web?user_id=${username}`, {
        headers: { 'Authorization': `Bearer ${token}` }
      });
      
      if (response.ok) {
        const data = await response.json();
        console.log('Loaded concept web data:', data);
        
        if (data.nodes && data.nodes.length > 0) {
          setConcepts(data.nodes);
          setConnections(data.connections || []);
          setNodePositions(initializeNodePositions(data.nodes));
        } else if (isInitial && !autoGenerated) {
          // Auto-generate on first load if no concepts
          await autoGenerateConceptWeb(username);
        }
      }
    } catch (error) {
      console.error('Error loading concept web:', error);
    } finally {
      setLoading(false);
      setInitialLoad(false);
    }
  };

  // Auto-generate concept web
  const autoGenerateConceptWeb = async (username) => {
    try {
      setAutoGenerated(true);
      const token = localStorage.getItem('token');
      const response = await fetch(`${API_URL}/generate_concept_web`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${token}`
        },
        body: JSON.stringify({ user_id: username })
      });
      
      if (response.ok) {
        const data = await response.json();
        if (data.status !== 'no_content') {
          await loadConceptWeb(username);
        }
      }
    } catch (error) {
      console.error('Error auto-generating:', error);
    }
  };

  const generateConceptWeb = async () => {
    if (!window.confirm('Generate concept web from your learning content?')) {
      return;
    }
    
    try {
      setGenerating(true);
      const token = localStorage.getItem('token');
      const response = await fetch(`${API_URL}/generate_concept_web`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${token}`
        },
        body: JSON.stringify({ user_id: userName })
      });
      
      if (response.ok) {
        const data = await response.json();
        if (data.status === 'no_content') {
          alert('No learning content found!');
        } else {
          alert(`Generated ${data.concepts_created} concepts!`);
          await loadConceptWeb(userName);
        }
      }
    } catch (error) {
      console.error('Error generating:', error);
    } finally {
      setGenerating(false);
    }
  };

  const addConcept = async () => {
    if (!newConcept.name.trim()) {
      alert('Please enter a concept name');
      return;
    }
    
    try {
      const token = localStorage.getItem('token');
      const response = await fetch(`${API_URL}/add_concept_node`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${token}`
        },
        body: JSON.stringify({
          user_id: userName,
          concept_name: newConcept.name,
          description: newConcept.description,
          category: newConcept.category || 'General'
        })
      });
      
      if (response.ok) {
        setShowAddModal(false);
        setNewConcept({ name: '', description: '', category: '' });
        loadConceptWeb(userName);
      }
    } catch (error) {
      console.error('Error adding concept:', error);
    }
  };

  const deleteConcept = async (nodeId) => {
    if (!window.confirm('Delete this concept?')) return;
    
    try {
      const token = localStorage.getItem('token');
      await fetch(`${API_URL}/delete_concept_node/${nodeId}`, {
        method: 'DELETE',
        headers: { 'Authorization': `Bearer ${token}` }
      });
      loadConceptWeb(userName);
      setSelectedNode(null);
    } catch (error) {
      console.error('Error deleting:', error);
    }
  };

  const deleteAllConcepts = async () => {
    if (!window.confirm('Delete ALL concepts? This cannot be undone!')) return;
    
    try {
      const token = localStorage.getItem('token');
      const response = await fetch(`${API_URL}/delete_all_concepts?user_id=${userName}`, {
        method: 'DELETE',
        headers: { 'Authorization': `Bearer ${token}` }
      });
      
      if (response.ok) {
        setConcepts([]);
        setConnections([]);
        setSelectedNode(null);
        setNodePositions({});
        alert('All concepts deleted successfully');
      }
    } catch (error) {
      console.error('Error deleting all:', error);
      alert('Failed to delete all concepts');
    }
  };

  const getMasteryColor = (level) => {
    if (level < 0.3) return '#EF4444';
    if (level < 0.7) return '#F59E0B';
    return '#10B981';
  };

  // Get aesthetic color for node based on category
  const getCategoryColor = (category) => {
    const predefinedColors = {
      'Computer Science': '#3B82F6',
      'Mathematics': '#8B5CF6',
      'Physics': '#06B6D4',
      'Chemistry': '#10B981',
      'Biology': '#22C55E',
      'History': '#F59E0B',
      'Literature': '#EC4899',
      'Philosophy': '#A855F7',
      'Psychology': '#6366F1',
      'Economics': '#14B8A6',
      'Engineering': '#0EA5E9',
      'Art': '#F43F5E',
      'Music': '#D946EF',
      'Language': '#84CC16',
      'General': '#D7B38C',
      'Academic Field': '#3B82F6',
      'Social Skill': '#EC4899',
      'Communication': '#06B6D4',
      'Personal Growth': '#22C55E',
      'Personal Development': '#8B5CF6',
      'Personal Trait': '#F59E0B'
    };
    
    // If predefined color exists, use it
    if (predefinedColors[category]) {
      return predefinedColors[category];
    }
    
    // Otherwise generate a consistent color based on category name
    const colorPalette = [
      '#3B82F6', '#8B5CF6', '#06B6D4', '#10B981', '#22C55E',
      '#F59E0B', '#EC4899', '#A855F7', '#6366F1', '#14B8A6',
      '#0EA5E9', '#F43F5E', '#D946EF', '#84CC16', '#D7B38C'
    ];
    
    let hash = 0;
    for (let i = 0; i < category.length; i++) {
      hash = category.charCodeAt(i) + ((hash << 5) - hash);
    }
    return colorPalette[Math.abs(hash) % colorPalette.length];
  };

  const getConnectionColor = (type) => {
    const colors = {
      prerequisite: '#F59E0B',
      related: '#D7B38C',
      opposite: '#EF4444',
      example_of: '#10B981',
      part_of: '#3B82F6'
    };
    return colors[type] || '#D7B38C';
  };

  const getConnectedConcepts = (conceptId) => {
    return connections.filter(conn => 
      conn.source_id === conceptId || conn.target_id === conceptId
    );
  };

  const getCategories = () => {
    const categories = new Set(concepts.map(c => c.category));
    return ['all', ...Array.from(categories)];
  };

  const getFilteredAndSortedConcepts = () => {
    let filtered = concepts;

    if (searchQuery) {
      filtered = filtered.filter(c => 
        c.concept_name.toLowerCase().includes(searchQuery.toLowerCase()) ||
        c.description?.toLowerCase().includes(searchQuery.toLowerCase()) ||
        c.category.toLowerCase().includes(searchQuery.toLowerCase())
      );
    }

    if (filterCategory !== 'all') {
      filtered = filtered.filter(c => c.category === filterCategory);
    }

    filtered.sort((a, b) => {
      switch (sortBy) {
        case 'name':
          return a.concept_name.localeCompare(b.concept_name);
        case 'mastery':
          return b.mastery_level - a.mastery_level;
        case 'connections':
          return getConnectedConcepts(b.id).length - getConnectedConcepts(a.id).length;
        case 'content':
          const aTotal = a.notes_count + a.quizzes_count + a.flashcards_count;
          const bTotal = b.notes_count + b.quizzes_count + b.flashcards_count;
          return bTotal - aTotal;
        default:
          return 0;
      }
    });

    return filtered;
  };

  const getStats = () => {
    const totalConcepts = concepts.length;
    const totalConnections = connections.length;
    const avgMastery = concepts.length > 0 
      ? Math.round((concepts.reduce((sum, c) => sum + c.mastery_level, 0) / concepts.length) * 100)
      : 0;
    const categories = new Set(concepts.map(c => c.category)).size;
    
    const masteryDistribution = {
      beginner: concepts.filter(c => c.mastery_level < 0.3).length,
      intermediate: concepts.filter(c => c.mastery_level >= 0.3 && c.mastery_level < 0.7).length,
      advanced: concepts.filter(c => c.mastery_level >= 0.7).length
    };

    const mostConnected = concepts.length > 0 
      ? concepts.reduce((max, c) => {
          const connCount = getConnectedConcepts(c.id).length;
          return connCount > (max.count || 0) ? { concept: c, count: connCount } : max;
        }, {})
      : null;

    const totalContent = concepts.reduce((sum, c) => 
      sum + c.notes_count + c.quizzes_count + c.flashcards_count, 0
    );
    
    return { 
      totalConcepts, 
      totalConnections, 
      avgMastery, 
      categories,
      masteryDistribution,
      mostConnected,
      totalContent
    };
  };

  const toggleConceptSelection = (conceptId) => {
    const newSelected = new Set(selectedConcepts);
    if (newSelected.has(conceptId)) {
      newSelected.delete(conceptId);
    } else {
      newSelected.add(conceptId);
    }
    setSelectedConcepts(newSelected);
  };

  const selectAll = () => {
    setSelectedConcepts(new Set(getFilteredAndSortedConcepts().map(c => c.id)));
  };

  const deselectAll = () => {
    setSelectedConcepts(new Set());
  };

  const deleteSelected = async () => {
    if (selectedConcepts.size === 0) return;
    if (!window.confirm(`Delete ${selectedConcepts.size} selected concepts?`)) return;

    try {
      const token = localStorage.getItem('token');
      await Promise.all(
        Array.from(selectedConcepts).map(id =>
          fetch(`${API_URL}/delete_concept_node/${id}`, {
            method: 'DELETE',
            headers: { 'Authorization': `Bearer ${token}` }
          })
        )
      );
      loadConceptWeb(userName);
      setSelectedConcepts(new Set());
      setSelectedNode(null);
    } catch (error) {
      console.error('Error deleting selected:', error);
    }
  };

  const generateConceptContent = async (contentType) => {
    if (!selectedNode) return;
    
    const contentNames = {
      notes: 'study notes',
      flashcards: 'flashcards',
      quiz: 'practice quiz'
    };
    
    const endpoints = {
      notes: 'generate_concept_notes',
      flashcards: 'generate_concept_flashcards',
      quiz: 'generate_concept_quiz'
    };
    
    if (!window.confirm(`Generate AI-powered ${contentNames[contentType]} for "${selectedNode.concept_name}"?`)) {
      return;
    }
    
    try {
      setGeneratingContent(contentType);
      const token = localStorage.getItem('token');
      const response = await fetch(`${API_URL}/${endpoints[contentType]}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${token}`
        },
        body: JSON.stringify({
          user_id: userName,
          concept_id: selectedNode.id
        })
      });
      
      if (response.ok) {
        const data = await response.json();
        alert(`✅ Generated ${contentNames[contentType]}! Mastery increased to ${Math.round(data.new_mastery * 100)}%`);
        
        await loadConceptWeb(userName);
        
        if (contentType === 'notes' && data.note_id) {
          navigate(`/notes`);
        } else if (contentType === 'flashcards' && data.set_id) {
          navigate(`/flashcards`);
        } else if (contentType === 'quiz' && data.quiz_id) {
          navigate(`/quiz-hub`);
        }
      } else {
        const error = await response.json();
        alert(`Failed to generate content: ${error.detail}`);
      }
    } catch (error) {
      console.error('Error generating content:', error);
      alert('Failed to generate content');
    } finally {
      setGeneratingContent(null);
    }
  };

  const exportData = () => {
    const data = {
      concepts: concepts.map(c => ({
        name: c.concept_name,
        category: c.category,
        description: c.description,
        mastery: c.mastery_level,
        content: {
          notes: c.notes_count,
          quizzes: c.quizzes_count,
          flashcards: c.flashcards_count
        }
      })),
      connections: connections.map(c => {
        const source = concepts.find(con => con.id === c.source_id);
        const target = concepts.find(con => con.id === c.target_id);
        return {
          from: source?.concept_name,
          to: target?.concept_name,
          type: c.connection_type,
          strength: c.strength
        };
      }),
      stats: getStats(),
      exportDate: new Date().toISOString()
    };

    const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `concept-web-${new Date().toISOString().split('T')[0]}.json`;
    a.click();
    URL.revokeObjectURL(url);
  };

  // Drag and drop functionality
  const handleMouseDown = (e, conceptId) => {
    if (e.button !== 0) return;
    e.stopPropagation();
    
    const svg = svgRef.current;
    if (!svg) return;
    
    const rect = svg.getBoundingClientRect();
    const svgX = ((e.clientX - rect.left) / rect.width) * 100;
    const svgY = ((e.clientY - rect.top) / rect.height) * 100;
    
    const pos = nodePositions[conceptId];
    if (pos) {
      setDraggingNode(conceptId);
      setDragOffset({
        x: svgX - pos.x,
        y: svgY - pos.y
      });
    }
  };

  const handleMouseMove = useCallback((e) => {
    if (!draggingNode || !svgRef.current) return;
    
    const svg = svgRef.current;
    const rect = svg.getBoundingClientRect();
    const svgX = ((e.clientX - rect.left) / rect.width) * 100;
    const svgY = ((e.clientY - rect.top) / rect.height) * 100;
    
    setNodePositions(prev => ({
      ...prev,
      [draggingNode]: {
        ...prev[draggingNode],
        x: Math.max(5, Math.min(95, svgX - dragOffset.x)),
        y: Math.max(5, Math.min(95, svgY - dragOffset.y))
      }
    }));
  }, [draggingNode, dragOffset]);

  const handleMouseUp = useCallback(() => {
    setDraggingNode(null);
  }, []);

  useEffect(() => {
    if (draggingNode) {
      window.addEventListener('mousemove', handleMouseMove);
      window.addEventListener('mouseup', handleMouseUp);
      return () => {
        window.removeEventListener('mousemove', handleMouseMove);
        window.removeEventListener('mouseup', handleMouseUp);
      };
    }
  }, [draggingNode, handleMouseMove, handleMouseUp]);

  // Fullscreen toggle
  const toggleFullscreen = () => {
    setIsFullscreen(!isFullscreen);
  };

  // Reset positions
  const resetPositions = () => {
    setNodePositions(initializeNodePositions(concepts));
  };

  return (
    <div className={`concept-web-page ${isFullscreen ? 'fullscreen' : ''} ${fadeIn ? 'fade-in' : ''}`}>
      {/* Ethereal Header */}
      <header className="concept-web-header-ethereal">
        <div className="header-left">
          <button className="back-btn-ethereal" onClick={() => navigate('/dashboard')}>
            <ArrowLeft size={16} />
            <span>BACK</span>
          </button>
          <div className="header-title-section">
            <h1 className="page-title-ethereal">CONCEPT WEB</h1>
            <p className="page-subtitle-ethereal">Your Knowledge Universe</p>
          </div>
        </div>
        <div className="header-right-ethereal">
          {concepts.length > 0 && (
            <>
              <div className="stats-mini">
                <div className="stat-mini">
                  <span className="stat-mini-value">{getStats().totalConcepts}</span>
                  <span className="stat-mini-label">Concepts</span>
                </div>
                <div className="stat-mini">
                  <span className="stat-mini-value">{getStats().totalConnections}</span>
                  <span className="stat-mini-label">Links</span>
                </div>
                <div className="stat-mini">
                  <span className="stat-mini-value">{getStats().avgMastery}%</span>
                  <span className="stat-mini-label">Mastery</span>
                </div>
              </div>
              <div className="header-divider"></div>
            </>
          )}
          <button 
            className="icon-btn-ethereal" 
            onClick={() => setViewMode(viewMode === 'grid' ? 'network' : 'grid')}
            title={viewMode === 'grid' ? 'Network View' : 'Grid View'}
          >
            {viewMode === 'grid' ? <Network size={18} /> : <Grid size={18} />}
          </button>
          {viewMode === 'network' && concepts.length > 0 && (
            <>
              <button 
                className="icon-btn-ethereal" 
                onClick={resetPositions}
                title="Reset Layout"
              >
                <RefreshCw size={18} />
              </button>
              <button 
                className="icon-btn-ethereal" 
                onClick={toggleFullscreen}
                title={isFullscreen ? 'Exit Fullscreen' : 'Fullscreen'}
              >
                {isFullscreen ? <Minimize2 size={18} /> : <Maximize2 size={18} />}
              </button>
            </>
          )}
          <button className="icon-btn-ethereal" onClick={() => setShowAnalytics(!showAnalytics)} title="Analytics">
            <BarChart3 size={18} />
          </button>
          <button className="icon-btn-ethereal" onClick={exportData} title="Export">
            <Download size={18} />
          </button>
          <button className="add-btn-ethereal" onClick={() => setShowAddModal(true)}>
            <Plus size={16} />
            <span>ADD</span>
          </button>
        </div>
      </header>

      {/* Main Content Area */}
      <div className={`concept-web-container-ethereal ${isFullscreen ? 'fullscreen-container' : ''}`} ref={containerRef}>
        {loading && initialLoad ? (
          <div className="loading-state-ethereal">
            <div className="loading-animation">
              <div className="loading-circle"></div>
              <div className="loading-circle"></div>
              <div className="loading-circle"></div>
            </div>
            <h3 className="loading-title">Loading Your Map</h3>
            <p className="loading-subtitle">Preparing your knowledge universe...</p>
          </div>
        ) : concepts.length === 0 ? (
          <div className="empty-state-ethereal">
            <div className="empty-icon-container">
              <Brain size={80} />
            </div>
            <h3>No Concepts Yet</h3>
            <p>Start building your knowledge web by adding concepts or generating from your content</p>
            <div className="empty-actions">
              <button className="empty-action-btn secondary" onClick={() => setShowAddModal(true)}>
                <Plus size={18} />
                Add Manually
              </button>
            </div>
          </div>
        ) : (
          <>
            {/* Analytics Panel */}
            {showAnalytics && (
              <div className="analytics-panel-ethereal">
                <div className="analytics-header-ethereal">
                  <h3>ANALYTICS DASHBOARD</h3>
                  <button className="close-btn-ethereal" onClick={() => setShowAnalytics(false)}>×</button>
                </div>
                <div className="analytics-grid-ethereal">
                  <div className="analytics-card-ethereal">
                    <div className="analytics-card-header">
                      <Target size={20} />
                      <h4>MASTERY DISTRIBUTION</h4>
                    </div>
                    <div className="mastery-bars-ethereal">
                      <div className="mastery-bar-item-ethereal">
                        <span className="mastery-label-ethereal">BEGINNER</span>
                        <div className="mastery-bar-bg-ethereal">
                          <div 
                            className="mastery-bar-fill-ethereal beginner"
                            style={{ width: `${(getStats().masteryDistribution.beginner / concepts.length) * 100}%` }}
                          ></div>
                        </div>
                        <span className="mastery-count-ethereal">{getStats().masteryDistribution.beginner}</span>
                      </div>
                      <div className="mastery-bar-item-ethereal">
                        <span className="mastery-label-ethereal">INTERMEDIATE</span>
                        <div className="mastery-bar-bg-ethereal">
                          <div 
                            className="mastery-bar-fill-ethereal intermediate"
                            style={{ width: `${(getStats().masteryDistribution.intermediate / concepts.length) * 100}%` }}
                          ></div>
                        </div>
                        <span className="mastery-count-ethereal">{getStats().masteryDistribution.intermediate}</span>
                      </div>
                      <div className="mastery-bar-item-ethereal">
                        <span className="mastery-label-ethereal">ADVANCED</span>
                        <div className="mastery-bar-bg-ethereal">
                          <div 
                            className="mastery-bar-fill-ethereal advanced"
                            style={{ width: `${(getStats().masteryDistribution.advanced / concepts.length) * 100}%` }}
                          ></div>
                        </div>
                        <span className="mastery-count-ethereal">{getStats().masteryDistribution.advanced}</span>
                      </div>
                    </div>
                  </div>
                  
                  <div className="analytics-card-ethereal">
                    <div className="analytics-card-header">
                      <Zap size={20} />
                      <h4>MOST CONNECTED</h4>
                    </div>
                    {getStats().mostConnected?.concept ? (
                      <div className="highlight-concept-ethereal">
                        <h5>{getStats().mostConnected.concept.concept_name}</h5>
                        <p className="highlight-category">{getStats().mostConnected.concept.category}</p>
                        <div className="highlight-stat">
                          <LinkIcon size={16} />
                          <span>{getStats().mostConnected.count} connections</span>
                        </div>
                        <button 
                          className="view-btn-ethereal"
                          onClick={() => {
                            setSelectedNode(getStats().mostConnected.concept);
                            setShowAnalytics(false);
                          }}
                        >
                          VIEW DETAILS
                        </button>
                      </div>
                    ) : (
                      <p className="no-data">No connections yet</p>
                    )}
                  </div>

                  <div className="analytics-card-ethereal">
                    <div className="analytics-card-header">
                      <BookOpen size={20} />
                      <h4>CONTENT OVERVIEW</h4>
                    </div>
                    <div className="content-stats-ethereal">
                      <div className="content-stat-item-ethereal">
                        <FileText size={28} />
                        <div>
                          <span className="content-number-ethereal">{concepts.reduce((sum, c) => sum + c.notes_count, 0)}</span>
                          <span className="content-label-ethereal">NOTES</span>
                        </div>
                      </div>
                      <div className="content-stat-item-ethereal">
                        <Brain size={28} />
                        <div>
                          <span className="content-number-ethereal">{concepts.reduce((sum, c) => sum + c.quizzes_count, 0)}</span>
                          <span className="content-label-ethereal">QUIZZES</span>
                        </div>
                      </div>
                      <div className="content-stat-item-ethereal">
                        <BookOpen size={28} />
                        <div>
                          <span className="content-number-ethereal">{concepts.reduce((sum, c) => sum + c.flashcards_count, 0)}</span>
                          <span className="content-label-ethereal">FLASHCARDS</span>
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            )}

            {/* View Mode: Network or Grid */}
            {viewMode === 'network' ? (
              <div className={`network-view-ethereal ${selectedNode ? 'with-sidebar' : ''}`}>
                <svg 
                  ref={svgRef}
                  className="network-svg-ethereal" 
                  viewBox="0 0 100 100" 
                  preserveAspectRatio="xMidYMid meet"
                >
                  {/* Gradient Definitions */}
                  <defs>
                    {/* Create a glow gradient for each unique category */}
                    {Array.from(new Set(concepts.map(c => c.category))).map(category => (
                      <radialGradient key={category} id={`nodeGlow-${category.replace(/\s+/g, '-')}`} cx="50%" cy="50%" r="50%">
                        <stop offset="0%" stopColor={getCategoryColor(category)} stopOpacity="0.4" />
                        <stop offset="100%" stopColor={getCategoryColor(category)} stopOpacity="0" />
                      </radialGradient>
                    ))}
                    <filter id="glow">
                      <feGaussianBlur stdDeviation="0.5" result="coloredBlur"/>
                      <feMerge>
                        <feMergeNode in="coloredBlur"/>
                        <feMergeNode in="SourceGraphic"/>
                      </feMerge>
                    </filter>
                  </defs>

                  {/* Draw connections */}
                  <g className="connections-layer">
                    {connections.map((conn, idx) => {
                      const source = concepts.find(c => c.id === conn.source_id);
                      const target = concepts.find(c => c.id === conn.target_id);
                      if (!source || !target || !nodePositions[source.id] || !nodePositions[target.id]) return null;

                      const sourcePos = nodePositions[source.id];
                      const targetPos = nodePositions[target.id];

                      const isHighlighted = hoveredNode && 
                        (hoveredNode === source.id || hoveredNode === target.id);

                      return (
                        <line
                          key={`conn-${source.id}-${target.id}-${sourcePos.x}-${sourcePos.y}-${targetPos.x}-${targetPos.y}`}
                          x1={sourcePos.x}
                          y1={sourcePos.y}
                          x2={targetPos.x}
                          y2={targetPos.y}
                          stroke={isHighlighted ? getConnectionColor(conn.connection_type) : 'var(--border)'}
                          strokeWidth={isHighlighted ? 0.15 : 0.08}
                          strokeOpacity={isHighlighted ? 0.8 : 0.2}
                          className="connection-line-ethereal"
                        />
                      );
                    })}
                  </g>

                  {/* Draw nodes */}
                  <g className="nodes-layer">
                    {concepts.map((concept) => {
                      if (!nodePositions[concept.id]) return null;
                      
                      const pos = nodePositions[concept.id];
                      const isSelected = selectedNode?.id === concept.id;
                      const isHovered = hoveredNode === concept.id;
                      const connectedConcepts = getConnectedConcepts(concept.id);
                      const nodeSize = isHovered ? 1.8 : isSelected ? 1.65 : 1.5;

                      return (
                        <g 
                          key={concept.id}
                          className={`network-node-ethereal ${isSelected ? 'selected' : ''} ${isHovered ? 'hovered' : ''}`}
                          onMouseEnter={() => setHoveredNode(concept.id)}
                          onMouseLeave={() => setHoveredNode(null)}
                          onClick={() => setSelectedNode(concept)}
                          onMouseDown={(e) => handleMouseDown(e, concept.id)}
                          style={{ cursor: draggingNode === concept.id ? 'grabbing' : 'grab' }}
                        >
                          {/* Glow effect */}
                          {(isHovered || isSelected) && (
                            <circle
                              cx={pos.x}
                              cy={pos.y}
                              r={nodeSize * 2.5}
                              fill={`url(#nodeGlow-${concept.category.replace(/\s+/g, '-')})`}
                              className="node-glow"
                            />
                          )}
                          
                          {/* Main node circle */}
                          <circle
                            cx={pos.x}
                            cy={pos.y}
                            r={nodeSize}
                            fill={getCategoryColor(concept.category)}
                            stroke={isSelected ? getCategoryColor(concept.category) : '#4A4A4A'}
                            strokeWidth={isSelected ? 0.3 : 0.15}
                            className="node-circle-ethereal"
                            filter={isHovered || isSelected ? 'url(#glow)' : ''}
                            style={{ opacity: concept.mastery_level < 0.3 ? 0.6 : concept.mastery_level < 0.7 ? 0.8 : 1 }}
                          />
                          
                          {/* Node label */}
                          <text
                            x={pos.x}
                            y={pos.y - nodeSize - 0.8}
                            textAnchor="middle"
                            fill="var(--text-primary)"
                            fontSize="1.1"
                            fontWeight="700"
                            className="node-label-ethereal"
                            style={{ pointerEvents: 'none' }}
                          >
                            {concept.concept_name.length > 12 
                              ? concept.concept_name.substring(0, 12) + '...' 
                              : concept.concept_name}
                          </text>
                          
                          {/* Connection count badge */}
                          {connectedConcepts.length > 0 && (
                            <g>
                              <circle
                                cx={pos.x + nodeSize * 0.7}
                                cy={pos.y - nodeSize * 0.7}
                                r="0.65"
                                fill="var(--accent)"
                                stroke="var(--bg-bottom)"
                                strokeWidth="0.12"
                              />
                              <text
                                x={pos.x + nodeSize * 0.7}
                                y={pos.y - nodeSize * 0.7 + 0.35}
                                textAnchor="middle"
                                fill="var(--bg-bottom)"
                                fontSize="0.75"
                                fontWeight="800"
                                style={{ pointerEvents: 'none' }}
                              >
                                {connectedConcepts.length}
                              </text>
                            </g>
                          )}
                        </g>
                      );
                    })}
                  </g>
                </svg>

                {/* Hover Tooltip */}
                {hoveredNode && (
                  <div 
                    className="hover-tooltip-ethereal"
                    style={(() => {
                      const concept = concepts.find(c => c.id === hoveredNode);
                      if (!concept || !nodePositions[concept.id]) return {};
                      
                      const pos = nodePositions[concept.id];
                      const isLeftSide = pos.x < 50;
                      
                      if (isLeftSide) {
                        // Left side nodes - show tooltip on left, below legend
                        const bottomVariations = [40, 50, 60, 70, 80];
                        const randomBottom = bottomVariations[Math.floor(Math.random() * bottomVariations.length)];
                        return {
                          left: '40px',
                          bottom: `${randomBottom}px`
                        };
                      } else {
                        // Right side nodes - show tooltip on right
                        const topVariations = [120, 150, 180, 210, 240];
                        const randomTop = topVariations[Math.floor(Math.random() * topVariations.length)];
                        return {
                          right: '40px',
                          top: `${randomTop}px`
                        };
                      }
                    })()}
                  >
                    {(() => {
                      const concept = concepts.find(c => c.id === hoveredNode);
                      if (!concept) return null;
                      
                      return (
                        <>
                          <div className="tooltip-header">
                            <h4>{concept.concept_name}</h4>
                            <span className="tooltip-category">{concept.category}</span>
                          </div>
                          {concept.description && (
                            <p className="tooltip-description">{concept.description}</p>
                          )}
                          <div className="tooltip-stats">
                            <div className="tooltip-stat">
                              <span className="tooltip-stat-label">MASTERY</span>
                              <span className="tooltip-stat-value" style={{ color: getMasteryColor(concept.mastery_level) }}>
                                {Math.round(concept.mastery_level * 100)}%
                              </span>
                            </div>
                            <div className="tooltip-stat">
                              <span className="tooltip-stat-label">CONNECTIONS</span>
                              <span className="tooltip-stat-value">
                                {getConnectedConcepts(concept.id).length}
                              </span>
                            </div>
                          </div>
                          <div className="tooltip-content-grid">
                            <div className="tooltip-content-item">
                              <FileText size={14} />
                              <span>{concept.notes_count}</span>
                            </div>
                            <div className="tooltip-content-item">
                              <Brain size={14} />
                              <span>{concept.quizzes_count}</span>
                            </div>
                            <div className="tooltip-content-item">
                              <BookOpen size={14} />
                              <span>{concept.flashcards_count}</span>
                            </div>
                          </div>
                          <div className="tooltip-hint">
                            <Info size={12} />
                            <span>Click to view details • Drag to move</span>
                          </div>
                        </>
                      );
                    })()}
                  </div>
                )}

                {/* Network Controls */}
                <div className="network-controls-ethereal">
                  <div className="control-hint">
                    <Move size={14} />
                    <span>Drag nodes to reposition</span>
                  </div>
                  {concepts.length > 0 && (
                    <div className="color-legend-ethereal">
                      <div className="legend-title">CATEGORIES</div>
                      {Array.from(new Set(concepts.map(c => c.category))).slice(0, 6).map(category => (
                        <div key={category} className="legend-item">
                          <div 
                            className="legend-color" 
                            style={{ background: getCategoryColor(category) }}
                          ></div>
                          <span>{category}</span>
                        </div>
                      ))}
                    </div>
                  )}
                </div>
              </div>
            ) : (
              // Grid View
              <div className="grid-view-ethereal">
                {/* Search and Filters */}
                <div className="controls-bar-ethereal">
                  <div className="search-box-ethereal">
                    <Search size={16} />
                    <input
                      type="text"
                      placeholder="Search concepts..."
                      value={searchQuery}
                      onChange={(e) => setSearchQuery(e.target.value)}
                    />
                  </div>
                  
                  <div className="filter-group-ethereal">
                    <label>CATEGORY</label>
                    <select value={filterCategory} onChange={(e) => setFilterCategory(e.target.value)}>
                      {getCategories().map(cat => (
                        <option key={cat} value={cat}>{cat === 'all' ? 'All' : cat}</option>
                      ))}
                    </select>
                  </div>

                  <div className="filter-group-ethereal">
                    <label>SORT</label>
                    <select value={sortBy} onChange={(e) => setSortBy(e.target.value)}>
                      <option value="name">Name</option>
                      <option value="mastery">Mastery</option>
                      <option value="connections">Connections</option>
                      <option value="content">Content</option>
                    </select>
                  </div>
                </div>

                {/* Concept Cards Grid */}
                <div className="concepts-grid-ethereal">
                  {getFilteredAndSortedConcepts().map((concept, index) => {
                    const connectedConcepts = getConnectedConcepts(concept.id);
                    const totalContent = concept.notes_count + concept.quizzes_count + concept.flashcards_count;
                    const isSelected = selectedNode?.id === concept.id;

                    return (
                      <div 
                        key={concept.id}
                        className={`concept-card-ethereal ${isSelected ? 'selected' : ''}`}
                        onClick={() => setSelectedNode(concept)}
                        style={{ 
                          animationDelay: `${index * 0.05}s`,
                          borderLeftColor: getMasteryColor(concept.mastery_level)
                        }}
                      >
                        {/* Top Half - Topic */}
                        <div className="card-top-half" style={{ background: `linear-gradient(135deg, ${getCategoryColor(concept.category)}15, ${getCategoryColor(concept.category)}05)` }}>
                          <h3 className="card-title-poster">{concept.concept_name}</h3>
                          {concept.description && (
                            <p className="card-description-poster">{concept.description}</p>
                          )}
                        </div>

                        {/* Bottom Half - Stats */}
                        <div className="card-bottom-half">
                          <div className="card-category-badge">{concept.category}</div>
                          <div className="card-mastery-display">
                            <span className="mastery-label-poster">MASTERY</span>
                            <span className="mastery-value-poster" style={{ color: getMasteryColor(concept.mastery_level) }}>
                              {Math.round(concept.mastery_level * 100)}%
                            </span>
                          </div>
                          
                          <div className="card-stats-poster">
                            <div className="stat-item-poster">
                              <FileText size={14} />
                              <span>{concept.notes_count} Notes</span>
                            </div>
                            <div className="stat-item-poster">
                              <Brain size={14} />
                              <span>{concept.quizzes_count} Quizzes</span>
                            </div>
                            <div className="stat-item-poster">
                              <BookOpen size={14} />
                              <span>{concept.flashcards_count} Cards</span>
                            </div>
                          </div>

                          {connectedConcepts.length > 0 && (
                            <div className="card-connections-poster">
                              <LinkIcon size={12} />
                              <span>{connectedConcepts.length} Connection{connectedConcepts.length !== 1 ? 's' : ''}</span>
                            </div>
                          )}
                        </div>
                      </div>
                    );
                  })}
                </div>

                {getFilteredAndSortedConcepts().length === 0 && (
                  <div className="no-results-ethereal">
                    <Search size={48} />
                    <p>No concepts match your search</p>
                  </div>
                )}
              </div>
            )}
          </>
        )}
      </div>

      {/* Detail Panel */}
      {selectedNode && (
        <div className={`detail-panel-ethereal ${isPanelCollapsed ? 'collapsed' : ''}`}>
          <div className="panel-header-ethereal">
            {!isPanelCollapsed && (
              <div className="panel-title-section">
                <h3>{selectedNode.concept_name}</h3>
                <span className="panel-category">{selectedNode.category}</span>
              </div>
            )}
            <div className="panel-actions">
              <button 
                className="panel-btn" 
                onClick={() => setIsPanelCollapsed(!isPanelCollapsed)}
                title={isPanelCollapsed ? "Expand" : "Collapse"}
              >
                {isPanelCollapsed ? <Eye size={16} /> : <EyeOff size={16} />}
              </button>
              <button 
                className="panel-btn" 
                onClick={() => {
                  setSelectedNode(null);
                  setIsPanelCollapsed(false);
                }}
                title="Close"
              >
                ×
              </button>
            </div>
          </div>
          
          {!isPanelCollapsed && (
            <div className="panel-content-ethereal">
              {/* Description */}
              {selectedNode.description && (
                <div className="panel-section">
                  <label className="panel-label">DESCRIPTION</label>
                  <p className="panel-text">{selectedNode.description}</p>
                </div>
              )}

              {/* Mastery Level */}
              <div className="panel-section">
                <label className="panel-label">MASTERY LEVEL</label>
                <div className="mastery-display-ethereal">
                  <div className="mastery-bar-large-ethereal">
                    <div 
                      className="mastery-fill-ethereal" 
                      style={{ 
                        width: `${selectedNode.mastery_level * 100}%`,
                        background: getMasteryColor(selectedNode.mastery_level)
                      }}
                    ></div>
                  </div>
                  <span 
                    className="mastery-percent-ethereal"
                    style={{ color: getMasteryColor(selectedNode.mastery_level) }}
                  >
                    {Math.round(selectedNode.mastery_level * 100)}%
                  </span>
                </div>
              </div>

              {/* Content Generation */}
              <div className="panel-section">
                <label className="panel-label">GENERATE CONTENT</label>
                <div className="content-generation-grid">
                  <button 
                    className={`gen-btn-ethereal ${generatingContent === 'notes' ? 'generating' : ''}`}
                    onClick={() => generateConceptContent('notes')}
                    disabled={generatingContent !== null}
                  >
                    <FileText size={18} />
                    <div className="gen-btn-content">
                      <span className="gen-btn-count">{selectedNode.notes_count}</span>
                      <span className="gen-btn-label">NOTES</span>
                    </div>
                    {generatingContent === 'notes' ? (
                      <Loader size={14} className="spinner" />
                    ) : (
                      <Sparkles size={14} className="gen-btn-icon" />
                    )}
                  </button>
                  
                  <button 
                    className={`gen-btn-ethereal ${generatingContent === 'quiz' ? 'generating' : ''}`}
                    onClick={() => generateConceptContent('quiz')}
                    disabled={generatingContent !== null}
                  >
                    <Brain size={18} />
                    <div className="gen-btn-content">
                      <span className="gen-btn-count">{selectedNode.quizzes_count}</span>
                      <span className="gen-btn-label">QUIZZES</span>
                    </div>
                    {generatingContent === 'quiz' ? (
                      <Loader size={14} className="spinner" />
                    ) : (
                      <Sparkles size={14} className="gen-btn-icon" />
                    )}
                  </button>
                  
                  <button 
                    className={`gen-btn-ethereal ${generatingContent === 'flashcards' ? 'generating' : ''}`}
                    onClick={() => generateConceptContent('flashcards')}
                    disabled={generatingContent !== null}
                  >
                    <BookOpen size={18} />
                    <div className="gen-btn-content">
                      <span className="gen-btn-count">{selectedNode.flashcards_count}</span>
                      <span className="gen-btn-label">FLASHCARDS</span>
                    </div>
                    {generatingContent === 'flashcards' ? (
                      <Loader size={14} className="spinner" />
                    ) : (
                      <Sparkles size={14} className="gen-btn-icon" />
                    )}
                  </button>
                </div>
                <div className="gen-hint-ethereal">
                  <Zap size={12} />
                  <span>Generate content to boost mastery by 10%</span>
                </div>
              </div>

              {/* Connections */}
              {getConnectedConcepts(selectedNode.id).length > 0 && (
                <div className="panel-section">
                  <label className="panel-label">CONNECTIONS</label>
                  <div className="connections-list-ethereal">
                    {getConnectedConcepts(selectedNode.id).map(conn => {
                      const targetId = conn.source_id === selectedNode.id ? conn.target_id : conn.source_id;
                      const targetConcept = concepts.find(c => c.id === targetId);
                      if (!targetConcept) return null;
                      
                      return (
                        <div 
                          key={conn.id} 
                          className="connection-item-ethereal"
                          onClick={() => setSelectedNode(targetConcept)}
                        >
                          <div 
                            className="connection-type-badge"
                            style={{ background: getConnectionColor(conn.connection_type) }}
                          >
                            {conn.connection_type.replace('_', ' ')}
                          </div>
                          <span className="connection-target">{targetConcept.concept_name}</span>
                          <ArrowLeft size={14} className="connection-arrow" />
                        </div>
                      );
                    })}
                  </div>
                </div>
              )}

              {/* Delete Button */}
              <button 
                className="delete-btn-ethereal" 
                onClick={() => deleteConcept(selectedNode.id)}
              >
                <Trash2 size={16} />
                DELETE CONCEPT
              </button>
            </div>
          )}
        </div>
      )}

      {/* Add Concept Modal */}
      {showAddModal && (
        <div className="modal-overlay-ethereal" onClick={() => setShowAddModal(false)}>
          <div className="modal-ethereal" onClick={e => e.stopPropagation()}>
            <div className="modal-header-ethereal">
              <h3>ADD NEW CONCEPT</h3>
              <button className="modal-close-btn" onClick={() => setShowAddModal(false)}>×</button>
            </div>
            <div className="modal-body-ethereal">
              <div className="form-group-ethereal">
                <label>CONCEPT NAME *</label>
                <input
                  type="text"
                  value={newConcept.name}
                  onChange={e => setNewConcept({...newConcept, name: e.target.value})}
                  placeholder="e.g., Machine Learning"
                  autoFocus
                />
              </div>
              <div className="form-group-ethereal">
                <label>CATEGORY</label>
                <input
                  type="text"
                  value={newConcept.category}
                  onChange={e => setNewConcept({...newConcept, category: e.target.value})}
                  placeholder="e.g., Computer Science"
                />
              </div>
              <div className="form-group-ethereal">
                <label>DESCRIPTION</label>
                <textarea
                  value={newConcept.description}
                  onChange={e => setNewConcept({...newConcept, description: e.target.value})}
                  placeholder="Brief description of the concept..."
                  rows="4"
                />
              </div>
            </div>
            <div className="modal-footer-ethereal">
              <button className="modal-btn-cancel" onClick={() => setShowAddModal(false)}>
                CANCEL
              </button>
              <button className="modal-btn-create" onClick={addConcept}>
                <Plus size={16} />
                ADD CONCEPT
              </button>
            </div>
          </div>
        </div>
      )}

      {/* Floating Action Hint */}
      {!selectedNode && concepts.length > 0 && !showAnalytics && viewMode === 'network' && (
        <div className="floating-hint-ethereal">
          <div className="hint-content">
            <Eye size={14} />
            <span>Hover over nodes for info • Click to view details</span>
          </div>
        </div>
      )}
    </div>
  );
};

export default ConceptWeb;
